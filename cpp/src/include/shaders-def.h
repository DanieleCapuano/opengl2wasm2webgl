#define CUBE_VERT "#version 300 es\n precision mediump float; layout (location = 0) in vec3 a_position; layout (location = 1) in vec3 a_normal; uniform mat4 u_modelview; uniform mat4 u_projection; out vec3 mynormal; out vec4 myvertex; void main() { gl_Position = u_projection * u_modelview * vec4(a_position, 1.0); mynormal = mat3(transpose(inverse(u_modelview))) * a_normal; myvertex = u_modelview * vec4(a_position, 1.0) ; } ";
#define CUBE_FRAG "#version 300 es\n precision mediump float; /* This is the fragment shader for reading in a scene description, including lighting.  Uniform lights are specified from the main program, and used in the shader.  As well as the material parameters of the object.  */ in vec3 mynormal; in vec4 myvertex; uniform float u_time; uniform float u_opacity; const int MAX_LIGHTS_N = 10; uniform int u_nlights; uniform vec4 u_lightposn[MAX_LIGHTS_N]; uniform vec4 u_lightcolor[MAX_LIGHTS_N]; uniform vec4 u_ambient; uniform vec4 u_diffuse; uniform vec4 u_specular; uniform vec4 u_emission; uniform float u_shininess; out vec4 fragColor; vec4 computeLight (const in vec3 direction, const in vec4 lightcolor, const in vec3 normal, const in vec3 halfvec, const in vec4 mydiffuse, const in vec4 myspecular, const in float myshininess) { float nDotL = dot(normal, direction)  ; vec4 lambert = (mydiffuse * lightcolor) * max (nDotL, 0.0) ; float nDotH = dot(normal, halfvec) ; vec4 phong = (myspecular * lightcolor) * pow (max(nDotH, 0.0), myshininess) ; vec4 retval = lambert + phong ; return retval ; } vec4 manageLights(void) { const vec3 eyepos = vec3(0.,0.,0.) ;  vec3 mypos = myvertex.xyz / myvertex.w ; vec3 eyedirn = normalize(eyepos - mypos); vec4 retcolor = vec4(0., 0., 0., 0.); vec3 halfvec, direction; vec3 normal = normalize(mynormal) ; int i; for (i=0; i< u_nlights; i++) { if (u_lightposn[i].w == 0.) { direction = normalize (u_lightposn[i].xyz) ; halfvec = normalize (direction + eyedirn) ; retcolor += computeLight(direction, u_lightcolor[i], normal, halfvec, u_diffuse, u_specular, u_shininess) ; } else { vec3 position = u_lightposn[i].xyz / u_lightposn[i].w ; direction = normalize (position - mypos) ; halfvec = normalize (direction + eyedirn) ; retcolor += computeLight(direction, u_lightcolor[i], normal, halfvec, u_diffuse, u_specular, u_shininess) ; } } return retcolor; } void main (void) { vec4 zero_one_color = u_ambient + u_emission + manageLights(); fragColor = zero_one_color;  } ";
